# ${envfn: ssoConfig }
# The base path of dex and the external name of the OpenID Connect service.
# This is the canonical URL that all clients MUST use to refer to dex. If a
# path is provided, dex's HTTP service will listen at a non-root URL.
issuer: ${env:// .ssoIssuer }

# The storage configuration determines where dex stores its state. Supported
# options include SQL flavors and Kubernetes third party resources.
#
# See the storage document at Documentation/storage.md for further information.
storage:
  type: postgres
  config:
    host: ${env:// .postgresHost }
    database: ${env:// .ssoDBName }
    user: ${env:// .ssoDBUser }
    password: ${env:// .ssoDBPassword }
    ssl:
      mode: disable

# Configuration for the HTTP endpoints.
web:
  http: 0.0.0.0:5556
  # Uncomment for HTTPS options.
  # https: 127.0.0.1:5554
  # tlsCert: /etc/dex/tls.crt
  # tlsKey: /etc/dex/tls.key
  allowedOrigins: ['*']

# Configuration for telemetry
telemetry:
  http: 0.0.0.0:5558

frontend:
  Theme:  meera
  Issuer: Meera DX

# Uncomment this block to enable the gRPC API. This values MUST be different
# from the HTTP endpoints.
grpc:
  addr: 0.0.0.0:5557
#  tlsCert: examples/grpc-client/server.crt
#  tlsKey: examples/grpc-client/server.key
#  tlsClientCA: /etc/dex/client.crt

# Uncomment this block to enable configuration for the expiration time durations.
# expiry:
#   signingKeys: "6h"
#   idTokens: "24h"

# Options for controlling the logger.
# logger:
#   level: "debug"
#   format: "text" # can also be "json"

# Uncomment this block to control which response types dex supports. For example
# the following response types enable the implicit flow for web-only clients.
# Defaults to ["code"], the code flow.
oauth2:
  responseTypes: ["code", "token", "id_token"]

# Instead of reading from an external storage, use this list of clients.
#
# If this option isn't chosen clients may be added through the gRPC API.
staticClients:
- id: example-app
  redirectURIs:
    - '${env:// .ssoClientAddr }/callback'
  name: 'Example App'
  secret: ZXhhbXBsZS1hcHAtc2VjcmV0
  allowedAuthTypes:
    - authorization_code
    - implicit
    - client_credentials
    - password_credentials

- id: access-control
  redirectURIs:
    - '${env:// .acRESTAddr }/oauth2'
    - '${env:// .acConsoleAddr }/oauth2'
  name: 'Access-control'
  secret: DzXZxyDObSpsnR7qLqQ4p1LEVoIiE49e
  allowedAuthTypes:
    - authorization_code
    - implicit
    - client_credentials
    - password_credentials

- id: ${env:// .configuratorClientID | default configurator}
  redirectURIs:
    - '${env:// .configuratorWebAddr }/sso/callback'
  name: 'Configurator'
  secret: DzXZxyDObSpsnR7qLqQ4p1LEVoIiE49e
  allowedAuthTypes:
    - authorization_code
    - implicit
    - client_credentials
    - password_credentials

#defaultConnectorID: "ldap"

connectors:
- type: mockCallback
  id: mock
  name: Example
# - type: oidc
#   id: google
#   name: Google
#   config:
#     issuer: https://accounts.google.com
#     # Connector config values starting with a "$" will read from the environment.
#     clientID: $GOOGLE_CLIENT_ID
#     clientSecret: $GOOGLE_CLIENT_SECRET
#     redirectURI: http://127.0.0.1:5556/dex/callback
#     hostedDomains:
#     - $GOOGLE_HOSTED_DOMAIN
# - type: slack
#  id: slack
#  name: Slack
#  config:
    # Connector config values starting with a "$" will read from the environment.
#    clientID: ""
#    clientSecret: ""
#    redirectURI: http://localhost:5556/dex/callback
#- type: ldap
#  name: Active Directory
#  id: ldap
#  config:
#    # host: localhost:10389
#    host: 10.10.10.30:389
#
#    # No TLS for this setup.
#    insecureNoSSL: true
#
#    # This would normally be a read-only user.
#    # bindDN: cn=admin,dc=example,dc=org
#    bindDN: CN=readonly internal,CN=Users,DC=fuseim,DC=pri
#    # bindPW: admin
#    bindPW: Tes9ting
#
#    usernamePrompt: Username
#
#    userSearch:
#      baseDN: "OU=FUSE IM Users,DC=fuseim,DC=pri"
#      filter: "(objectClass=person)"
#      username: sAMAccountName
#      # "DN" (case sensitive) is a special attribute name. It indicates that
#      # this value should be taken from the entity's DN not an attribute on
#      # the entity.
#      idAttr: DN
#      emailAttr: userPrincipalName
#      nameAttr: cn
#
#      groupSearch:
#        baseDN: "CN=Users,DC=fuseim,DC=pri"
#        filter: ""
#
#        # A user is a member of a group when their DN matches
#        # the value of a "member" attribute on the group entity.
#        userAttr: DN
#        groupAttr: member
#
#        # The group name should be the "cn" value.
#        nameAttr: cn


# Let dex keep a list of passwords which can be used to login to dex.
enablePasswordDB: true

# A static list of passwords to login the end user. By identifying here, dex
# won't look in its underlying storage for passwords.
#
# If this option isn't chosen users may be added through the gRPC API.
staticPasswords:
- email: "admin@example.com"
  # bcrypt hash of the string "password"
  hash: "$2a$10$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W"
  username: "admin"
  userID: "08a8684b-db88-4b73-90a9-3cd1661f5466"


mailManager:
  grpcAddr: "localhost:6000"
  sender: "no-reply-dev@target-energysolutions.com"
  issuer: "Meera DX"
#  caPath: examples/grpc-client/ca.crt
#  clientKey: examples/grpc-client/client.key
#  clientCrt: examples/grpc-client/client.crt
#  cnameOverride: ""

enableSignup: true

#accessControl:
#    enable: true
#    grpcAddr: "127.0.0.1:7001"

#profile:
#  enable: true
#  httpAddr: "http://profile-graphql:9301"
#  grpcAddr: "profile-grpc:50051"
#  caPath: examples/grpc-client/ca.crt
#  clientKey: examples/grpc-client/client.key
#  clientCrt: examples/grpc-client/client.crt
#  cnameOverride: ""

#licenseManager:
#  enable: true
#  addr: "lm-server:6000"
  #  caPath: examples/grpc-client/ca.crt
  #  clientKey: examples/grpc-client/client.key
  #  clientCrt: examples/grpc-client/client.crt
