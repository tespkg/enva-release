# ${envfn: ssoConfig }
# The base path of dex and the external name of the OpenID Connect service.
# This is the canonical URL that all clients MUST use to refer to dex. If a
# path is provided, dex's HTTP service will listen at a non-root URL.
issuer: ${env:// .ssoIssuer }

# The storage configuration determines where dex stores its state. Supported
# options include SQL flavors and Kubernetes third party resources.
#
# See the storage document at Documentation/storage.md for further information.
storage:
  type: postgres
  config:
    dsn: ${env:// .ssoDSN }

# Configuration for the HTTP endpoints.
web:
  http: 0.0.0.0:5556
  # Uncomment for HTTPS options.
  # https: 127.0.0.1:5554
  # tlsCert: /etc/dex/tls.crt
  # tlsKey: /etc/dex/tls.key
  allowedOrigins: ['*']

# Configuration for telemetry
telemetry:
  http: 0.0.0.0:5558

frontend:
  Theme:  meera
  Issuer: Meera DX

# Uncomment this block to enable the gRPC API. This values MUST be different
# from the HTTP endpoints.
grpc:
  addr: 0.0.0.0:5557
#  tlsCert: examples/grpc-client/server.crt
#  tlsKey: examples/grpc-client/server.key
#  tlsClientCA: /etc/dex/client.crt

# Uncomment this block to enable configuration for the expiration time durations.
# expiry:
#   signingKeys: "6h"
#   idTokens: "24h"

# Options for controlling the logger.
# logger:
#   level: "debug"
#   format: "text" # can also be "json"

# Uncomment this block to control which response types dex supports. For example
# the following response types enable the implicit flow for web-only clients.
# Defaults to ["code"], the code flow.
oauth2:
  responseTypes: ["code", "token", "id_token"]

# Instead of reading from an external storage, use this list of clients.
#
# If this option isn't chosen clients may be added through the gRPC API.
staticClients:
  - id: ${env:// .internalAppClientID | default internal-app }
    secret: ${env:// .internalAppClientSecret | default ZXhhbXBsZS1hcHAtc2VjcmV0 }
    allowedAuthTypes:
      - authorization_code
      - implicit
      - client_credentials
      - password_credentials
    name: "Internal App"

#defaultConnectorID: "ldap"

connectors:
  - type: mockCallback
    id: mock
    name: Example
# - type: oidc
#   id: google
#   name: Google
#   config:
#     issuer: https://accounts.google.com
#     # Connector config values starting with a "$" will read from the environment.
#     clientID: $GOOGLE_CLIENT_ID
#     clientSecret: $GOOGLE_CLIENT_SECRET
#     redirectURI: http://127.0.0.1:5556/dex/callback
#     hostedDomains:
#     - $GOOGLE_HOSTED_DOMAIN
# - type: slack
#  id: slack
#  name: Slack
#  config:
    # Connector config values starting with a "$" will read from the environment.
#    clientID: ""
#    clientSecret: ""
#    redirectURI: http://localhost:5556/dex/callback
#- type: ldap
#  name: Active Directory
#  id: ldap
#  config:
#    # host: localhost:10389
#    host: 10.10.10.30:389
#
#    # No TLS for this setup.
#    insecureNoSSL: true
#
#    # This would normally be a read-only user.
#    # bindDN: cn=admin,dc=example,dc=org
#    bindDN: CN=readonly internal,CN=Users,DC=fuseim,DC=pri
#    # bindPW: admin
#    bindPW: Tes9ting
#
#    usernamePrompt: Username
#
#    userSearch:
#      baseDN: "OU=FUSE IM Users,DC=fuseim,DC=pri"
#      filter: "(objectClass=person)"
#      username: sAMAccountName
#      # "DN" (case sensitive) is a special attribute name. It indicates that
#      # this value should be taken from the entity's DN not an attribute on
#      # the entity.
#      idAttr: DN
#      emailAttr: userPrincipalName
#      nameAttr: cn
#
#      groupSearch:
#        baseDN: "CN=Users,DC=fuseim,DC=pri"
#        filter: ""
#
#        # A user is a member of a group when their DN matches
#        # the value of a "member" attribute on the group entity.
#        userAttr: DN
#        groupAttr: member
#
#        # The group name should be the "cn" value.
#        nameAttr: cn


# Let dex keep a list of passwords which can be used to login to dex.
enablePasswordDB: true

# A static list of passwords to login the end user. By identifying here, dex
# won't look in its underlying storage for passwords.
#
# If this option isn't chosen users may be added through the gRPC API.
staticPasswords:
  - email: ${env:// .internalAppUsername | default admin@example.com }
    # bcrypt hash of the string "${env:// .internalAppPassword | default password }"
    hash: "$2a$10$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W"
    username: "admin"
    userID: "08a8684b-db88-4b73-90a9-3cd1661f5466"


mailManager:
  grpcAddr: "localhost:6000"
  sender: "no-reply@target-energysolutions.com"
  issuer: "Meera DX"
#  caPath: examples/grpc-client/ca.crt
#  clientKey: examples/grpc-client/client.key
#  clientCrt: examples/grpc-client/client.crt
#  cnameOverride: ""

enableSignup: true

accessControl:
  enable: true
  grpcAddr: ${envo:// .acGRPCAddr }

profile:
  enable: true
  httpAddr: ${envo:// .profileInternalHTTPAddr }
  grpcAddr: ${envo:// .profileGRPCAddr }
#  caPath: examples/grpc-client/ca.crt
#  clientKey: examples/grpc-client/client.key
#  clientCrt: examples/grpc-client/client.crt
#  cnameOverride: ""

logger:
  level: debug

scanExpiredInvitationPeriod: 1

# to set expired time of token when the user clicks the remember me button. the default value is 24h.
# such as "300ms", "-1.5h" or "2h45m". Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
rememberToPostpone: 21600m

# user needs to accept the system terms of service when they do:
#  1. on the sign up procedure
#  2. and on the first login (they could be created by admin).
# termsOfServicePath: "./examples/terms-of-service.html"
termsOfServicePath: ""
# to set mode of terms of service
#  1. "": show the term on the sign up procedure and on the first login (they could be created by admin).
#  2. "loop": show the term on the sign up procedure and on login every time.
#termsOfServiceMode: "loop"

passwordManager:
  # to set minimum length of password. the default value is 6.
  minLength: 6
  # to set password check rules.
  #  - (?=.*[A-Z]): at least one capital letter
  #  - (?=.*[0-9]): at least one decimal digit
  checkRule: "(?=.*[A-Z])(?=.*[0-9])"
  # to set a checking rule error message.
  errMsg : "combination of numbers and characters with at least ONE capital letter"
  # is allowed the same/different password. The default value is false
  isAllowedSamePassword: false
  # is allowed the expired password login. The default value is false
  isAllowedExpiredPasswordLogin: false
  # the next expiration date will be set [expiredPeriod] after user updating the password.
  # when the value is "", there is no notification to send.
  # must to be set an integer "m" (minute) or "h" (hour). such as "0h", "24h".
  # users are blocked to send email:
  #   - users are deleted
  #   - users are locked
  #   - unverified emails
  expiredPeriod: 1344h
  # notification will be sent by email [reminderPeriod] before the expiration date
  # must to be set an integer "m" (minute) or "h" (hour). such as "0h", "24h".
  reminderPeriod: 168h
  # notification every [reminderInterval] within the beginning reminder date and the expiration date
  # must to be set an integer "m" (minute) or "h" (hour). such as "0h", "24h".
  reminderInterval: 24h
